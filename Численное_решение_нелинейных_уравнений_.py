# -*- coding: utf-8 -*-
"""Копия блокнота "2. Численное решение нелинейных уравнений"

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fiND5GSAx1Yh1Sd6Q1iitZhjJxSomoSo

# Численное решение нелинейных уравнений

## Постановка задачи

Уравнение с одной переменной - это выражение вида:
\begin{align}
& f(x) = 0 \\
\end{align}

Пусть нам необходимо найти действительные корни этого уравнения.

Процесс численного решения задачи можно разбить на 2 этапа:
1. локализация корней, то есть поиск отрезков $[a, b]$, на которых уравнение имеет ровно один корень. Данный этап осуществляется методами математического анализа, в том числе построения таблицы значений функций, построения графика и т.п.
2. вычисление корней, принадлежащих найденным отрезкам, с требуемой точностью $\epsilon$. Это означает, что найденное приближенное значение корня $x$ должно отличаться от точного значения $x_0$ не более, чем на $\epsilon$:
\begin{align}
& |x - x_0| \le \epsilon \\
\end{align}

## Метод деления отрезка пополам (метод бисекции)

Идея метода деления отрезка пополам заключается в том, что на каждой итерации исследуется знак значения функции в середине отрезка и сравнивается со знаками значений на границах отрезка. Каждое следующее приближение ищется в том отрезке, у которого знаки значений на границах отличаются.

Говоря формально, обозначим отрезок на $i$-й итерации вычислений $[a_i, b_i]$.
В качестве первоначального отрезка выбираем отрезок $[a, b]$, то есть: 
\begin{align}
[a_0, b_0] = [a, b],\quad f(a)f(b) < 0
\end{align}
Тогда $i$-е приближение является серединой $i$-го отрезка:
\begin{align}
x_i = \frac{a_i+b_i}{2}
\end{align}
Следующий отрезок выбирается следующим образом:
\begin{align}
[a_{i+1}, b_{i+1}] = 
\begin{cases}
[a_i, x_i], & f(a_i)f(x_i) < 0 \\
[x_i, b_i], & f(x_i)f(b_i) < 0 \\
\end{cases}
\end{align}
Процесс продолжается до тех пор, пока
\begin{align}
& |x_i - x_{i - 1}| > \epsilon \\
\end{align}
Это условие можно переписать в виде:
\begin{align}
& b_i - a_i > 2 \epsilon \\
\end{align}

Можно заметить, что длина $i$-го отрезка равна:
\begin{align}
b_i - a_i = \frac{b - a}{2^i}
\end{align}

Отсюда можно вывести формулу количества итерации $N$, необходимых для получения ответа с точностью $\epsilon$. Условие остановки примет вид:
\begin{align}
\frac{b - a}{2^N} \le 2 \epsilon
\end{align}
Отсюда:
\begin{align}
& N \ge log_2{\frac{b - a}{2\epsilon}} \\
& N = \Big\lceil log_2{\frac{b - a}{2\epsilon}} \Big\rceil \\
\end{align}

### Задание

#### Реализация метода деления отрезка пополам

Реализуйте функцию `bisection(f, a, b, eps)`, находяющую решение нелинейного уравнения $f(x) = 0$ в отрезке $[a, b]$ с точностью $\epsilon$ с помощью метода деления отрезка пополам.

Параметры функции: 
* `f` - функция от одного числового аргумента;
* `a` - начало отрезка
* `b` - конец отрезка
* `eps` - точность решения

Функция должна возвращать 3 значения:
* искомое число $x$
* количество итераций, за которые оно было найдено
* список значений $x$ на каждой итерации
"""

def bisection(f, a, b, eps = 10e-9):
  x = 0
  n = 0
  x_list = []

  fa, fb = f(a), f(b)
  while b - a > 2 * eps:
    n += 1
    x = (a + b) / 2
    x_list.append(x)
    fx = f(x)
    if fa * fx < 0:
      b = x
      fb = fx
    elif fb * fx < 0:
      a = x
      fa = fx
    else:
      break

  return x, n, x_list

"""#### Использование метода деления отрезка пополам

С помощью реализованной функции найдите все корни уравнения (3 корня, если их больше)

**Варианты:**

\begin{align}
& 1. \quad e^{2x}\sin{x} = \cos{x} \\
& 2. \quad x^3 = \sin{x} \\
& 3. \quad x^3e^{x}\cos{x} = 0 \\
& 4. \quad x^2 \sin{x} + \ln{x} = 0 \\
& 5. \quad \ln{x} + 3 = x^2 \\
& 6. \quad 3x - x^3 = \sin{x} \\
& 7. \quad x^2 \sin{x} + \cos{x^2} = 0 \\
& 8. \quad \cos{x^2} = x \sin{x} \\
& 9. \quad x^2\cos{x^2}+e^x\ln{x} = 0 \\
& 10. \quad x^3\ln{x}+\cos{x} = 2 \\
& 11. \quad e^{4x}\cos{3x}+x^2 = 0 \\
& 12. \quad x^3e^{-x}+\sin{x^3} = 0 \\
\end{align}
"""

import math
def f(x):
  return math.exp(2*x) * math.sin(x) - math.cos(x)

"""С помощью библиотеки `matplotlib` постройте график функции $f(x)$"""

import matplotlib
import matplotlib.pyplot as plt
import numpy as np

plt.rcParams['figure.figsize'] = [12, 8]

funk = np.vectorize(f)

fig, ax = plt.subplots()
xx = np.arange(-1, 1, 0.001)
yy = funk(xx)
ax.plot(xx, yy, 'b')
ax.axhline(y = 0, color = 'k')
plt.show()

"""По графику определите отрезки $[a, b]$, которым принадлежат корни уравнения. Убедитесь, что значения функции на концах отрезков имеют разные знаки."""

a1 = -1.8
b1 = -1.4
print(f(a1)*f(b1) < 0)

a2 = 0
b2 = 1
print(f(a2)*f(b2) < 0)

"""С помощью реализованной ранее функции `bisection` вычислите с точностью до 9 знаков после запятой корни уравнения на найденных на предыдущем шаге отрезках"""

x1, _, _ = bisection(f, a1, b1) 
x2, _, _ = bisection(f, a2, b2)

[x1, x2]

"""Сделайте проверку, вычислив значения $f(x)$ для найденных корней. Покажите, что полученные значения близки к нулю."""

print(f(x1))
print(f(x2))

"""#### Изучение работы метода деления отрезка пополам

С помощью библиотеки `matplotlib` анимируйте работу метода деления отрезка пополам для нахождения одного из корней и проанализируйте полученный результат.

Для наглядности используйте небольшое значение точности (например, до третьего знака после запятой)
"""

import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import numpy as np

from matplotlib import rc
rc('animation', html='jshtml')

plt.rcParams['figure.figsize'] = [12, 8]

a = a1
b = b1
_, n, x_list = bisection(f, a, b, 10e-3)

fig, ax = plt.subplots()

ax.axhline(y = 0, color = 'k')

ax.plot([a, a], [0, f(a)], 'r:')
ax.plot([b, b], [0, f(b)], 'r:')

# Ваш код построения графика функции на отрезке [a, b] с шагом 0.01 
xx = np.arange(-1, 1, 0.01)
yy = funk(xx)
ax.plot(xx, yy, 'b')
ax.axhline(y = 0, color = 'k')
plt.show()
# Отобразите его синим цветом ('b')

def animate(i):
  """
  Функция animate рисует точку на графике, вычисленную в текущей итерации
  """
  x_i = x_list[i] # Ваше значение на i-й итерации
  f_i = f(x_i)
  ax.plot([x_i, x_i], [0, f_i], 'r:')
  ax.plot(x_i, f_i, 'ro')

animation.FuncAnimation(fig, animate, frames=n)

"""##  Метод секущих

Идея метода секущих состоит в том, что в качестве приближений к корню уравнения берутся точки пересечения хорд с осью абсцисс.

Обозначим точку $C_i(x_i; f(x_i))$. На каждой итерации рассматривается хорда $C_iC_{i-1}$. Найдем уравнение хорды $C_iC_{i-1}$ в виде $y=kx+b$.

\begin{cases}
f(x_i)=kx_i+b \\
f(x_{i-1})=kx_{i-1}+b
\end{cases}

Из системы находим коэффициенты $k$ и $b$:
\begin{align}
& k = \frac{f(x_i)-f(x_{i-1})}{x_i - x_{i-1}} \\
& b = \frac{x_if(x_{i-1})-x_{i-1}f(x_i)}{x_i - x_{i-1}} \\
\end{align}

Уравнение хорды примет вид:
\begin{align}
y = x \frac{f(x_i)-f(x_{i-1})}{x_i - x_{i-1}} + \frac{x_if(x_{i-1})-x_{i-1}f(x_i)}{x_i - x_{i-1}}
\end{align}

В качестве следующего приближения берется точка пересечения хорды $C_iC_{i-1}$ с осью абсцисс ($y = 0$):
\begin{align}
x_{i+1} = \frac{x_{i-1}f(x_i)-x_if(x_{i-1})}{f(x_i)-f(x_{i-1})}
\end{align}

Процесс продолжается до тех пор, пока $|x_i - x_{i-1}| \gt \epsilon$

### Задание

#### Реализация метода секущей

Реализуйте функцию `secant(f, x1, x2, eps, max_iter)`, находяющую решение нелинейного уравнения $𝑓(𝑥)=0$ c начальными приближениями $x_1$ и $x_2$ с точностью $\epsilon$ с помощью метода секущей.

Параметры функции: 
* `f` - функция от одного числового аргумента;
* `x1` - первое приближение
* `x2` - второе приближение
* `eps` - точность решения
* `max_iter` - максимальное количество итераций, за которые необходимо найти результат

Функция должна возвращать 3 значения:
* искомое число $x$
* количество итераций, за которые оно было найдено
* список значений $x$ на каждой итерации
"""

def secant(f, x1, x2, eps=10e-9, max_iter=100):
  x = 0
  n = 0
  x_list = [x1, x2]
  f1 = f(x1)
  f2 = f(x2)

  while abs(x2-x1) > eps and n < max_iter:
    n+= 1
    x = (x1 * f2 - x2* f1) / (f2 - f1)
    x_list.append(x)
    x1, x2 = x2, x
    f1, f2 = f2, f(x)

  return x, n, x_list

"""#### Использование метода секущей

С помощью реализованной ранее функции `secant` вычислите с точностью до 9 знаков после запятой корни уравнения на отрезках, использованных на методе деления отрезка пополам
"""

x1, _, _ = secant(f, a1, b1) 
x2, _, _ = secant(f, a2, b2)

[x1, x2]

"""Сделайте проверку, вычислив значения $f(x)$ для найденных корней. Покажите, что полученные значения близки к нулю."""

f(x1)
f(x2)

"""#### Изучение работы метода секущей

Выполните код из ячейки ниже. При корректной реализации функции `secant` отобразится анимация работы метода секущей.

Проанализируйте работу метода секущей пошагово.
"""

import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import numpy as np

from matplotlib import rc
rc('animation', html='jshtml')
plt.rcParams['figure.figsize'] = [12, 8]

a = a1
b = b1
_, n, x_list = secant(f, a, b, 10e-3)

fig, ax = plt.subplots()

ax.axhline(y = 0, color = 'k')
ax.plot([a, a], [0, f(a)], 'r:')
ax.plot([b, b], [0, f(b)], 'r:')

xx = np.arange(a, b, 10e-4)
yy = np.vectorize(f)(xx)
ax.plot(xx, yy, 'b')

def animate(i):
  """
  Функция animate для каждой итерации рисует хорду и найденное приближение
  """
  i += 2 # прибавляем 2, чтобы пропустить два заданных приближения
  x1, x2 = x_list[i - 2 : i]
  ax.plot([x1, x2, x_list[i]], [f(x1), f(x2), 0], 'r') # рисуем хорду
  ax.plot([x_list[i], x_list[i]], [0, f(x_list[i])], 'r:')
  ax.plot(x_list[i], f(x_list[i]), 'ro')

animation.FuncAnimation(fig, animate, frames=n)

"""## Метод Ньютона (метод касательных)

Идея метода Ньютона аналогична методу секущих. Он отличается тем, что вместо хорды используется касательная к графику функции в точке, абсцисса которой является приближение на предыдущем шаге.

Запишем уравнение касательной к графику функции в точке $(x_i, f(x_i))$. Поскольку производная функции в точке -- это тангенс угла наклона касательной к графику функции в этой точке, то уравнение касательной можно записать в виде:
\begin{align}
y = f'(x_i) (x - x_i) + f(x_i)
\end{align}

В качестве следующего приближения берется точка пересечения касательной с осью абсцисс ($y = 0$):
\begin{align}
x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}
\end{align}

Процесс продолжается до тех пор, пока $|x_i - x_{i-1}| \gt \epsilon$

Особенностью метода Ньютона является вычисление производной к исходной функции. Вычислять аналитически производную функции может быть затруднительным в случае сложной функции $f(x)$. 

На помощь приходит библиотека SymPy, позволяющая проводить символьные (алгебраические) вычисления. Код в ячейке ниже находит производную функции $f(x) = x \sin{x}$
"""

from sympy import *

x = symbols('x') # определяем x как математический символ
f_expr = x * sin(x) # получаем символьную запись функции f
df_expr = diff(f_expr, x) # вычисляем производную функции в символьном виде
print(df_expr)

# конвертируем символьную запись функции производной в Python-функцию
df = lambdify([x], df_expr) 
df(5)

"""### Задание

#### Реализация метода Ньютона

Реализуйте функцию `newton(f, df, x0, eps, max_iter)`, находяющую решение нелинейного уравнения $𝑓(𝑥)=0$ c начальными приближениями $x_1$ и $x_2$ с точностью $\epsilon$ с помощью метода секущей.

Параметры функции: 
* `f` - функция от одного числового аргумента;
* `df` - функция, вычисляющая производную функции $f(x)$ в точке;
* `x0` - первоначальное приближение;
* `eps` - точность решения.

Функция должна возвращать 3 значения:
* искомое число $x$;
* количество итераций, за которые оно было найдено;
* список значений $x$ на каждой итерации.
"""

def newton(f, df, x0, eps=10e-9, max_iter=100):
  x = x0 + f(x0) / df(x0)
  n = 1
  x_list = [x0, x]
  # Ваша реализация метода Ньютона
  while abs(x - x0) > eps and n < max_iter:
    n += 1
    x0 = x
    x = x0 + f(x0) / df(x0)
    x_list.append(x)

  return x, n, x_list

"""#### Использование метода Ньютона

С помощью SymPy найдите производную функции $f(x)$ для своего варианта.
"""

from sympy import *

x = symbols('x')

# Ваша реализация нахождения производной функции в символьном виде
# Результат положите в переменную df_expr
x = symbols('x')
f_expr = exp(2*x) * sin(x) - cos(x)
df_expr = diff(f_expr, x)
print(df_expr)

df = lambdify([x], df_expr)

"""С помощью реализованной ранее функции `newton` вычислите корни уравнения с точностью до 9 знаков после запятой. 

В качестве начальных приближений используйте результат работы метода деления отрезка пополам с точностью до 2 знаков после запятой.
"""

x0_1, _, _ = bisection(f, a1, b1)# Нахождение начального приближения для отрезка [a1, b1]
x0_2, _, _ = bisection(f, a2, b2)# Нахождение начального приближения для отрезка [a2, b2]

x0_1, x0_2

x1, _, _ = newton(f, df, x0_1) 
x2, _, _ = newton(f, df, x0_2) 

[x1, x2]

"""Сделайте проверку, вычислив значения $𝑓(𝑥)$ для найденных корней. Покажите, что полученные значения близки к нулю."""

f(x1), f(x2)

"""#### Изучение работы метода Ньютона

Выполните код из ячейки ниже. При корректной реализации функции `newton` отобразится анимация работы метода Ньютона.

Проанализируйте работу метода Ньютона пошагово. При необходимости измените начальное приближение `x0`.
"""

import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import numpy as np

from matplotlib import rc
rc('animation', html='jshtml')
plt.rcParams['figure.figsize'] = [12, 8]

fig, ax = plt.subplots()

x0 = b # при необходимости измените начальное приближение

x, n, x_list = newton(f, df, x0, 10e-3)

xx = np.arange(min(x_list), max(x_list), 10e-4)
yy = np.vectorize(f)(xx)
ax.plot(xx, yy, 'b')

ax.axhline(y = 0, color = 'k')
ax.plot([x0, x0], [0, f(x0)], 'r:')

def animate(i):
  prev, cur = x_list[i], x_list[i + 1]
  ax.plot([prev, cur], [f(prev), 0], 'r') # рисуем касательную
  ax.plot([cur, cur], [0, f(cur)], 'r:')
  ax.plot(cur, f(cur), 'ro')

animation.FuncAnimation(fig, animate, frames=n)