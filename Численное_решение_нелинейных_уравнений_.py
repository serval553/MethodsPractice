# -*- coding: utf-8 -*-
"""Копия блокнота "2. Численное решение нелинейных уравнений"

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fiND5GSAx1Yh1Sd6Q1iitZhjJxSomoSo

# Численное решение нелинейных уравнений

## Постановка задачи
Функция должна возвращать 3 значения:
* искомое число $x$
* количество итераций, за которые оно было найдено
* список значений $x$ на каждой итерации
"""

def bisection(f, a, b, eps = 10e-9):
  x = 0
  n = 0
  x_list = []

  fa, fb = f(a), f(b)
  while b - a > 2 * eps:
    n += 1
    x = (a + b) / 2
    x_list.append(x)
    fx = f(x)
    if fa * fx < 0:
      b = x
      fb = fx
    elif fb * fx < 0:
      a = x
      fa = fx
    else:
      break

  return x, n, x_list


import math
def f(x):
  return math.exp(2*x) * math.sin(x) - math.cos(x)

"""С помощью библиотеки `matplotlib` постройте график функции $f(x)$"""

import matplotlib
import matplotlib.pyplot as plt
import numpy as np

plt.rcParams['figure.figsize'] = [12, 8]

funk = np.vectorize(f)

fig, ax = plt.subplots()
xx = np.arange(-1, 1, 0.001)
yy = funk(xx)
ax.plot(xx, yy, 'b')
ax.axhline(y = 0, color = 'k')
plt.show()

"""По графику определите отрезки $[a, b]$, которым принадлежат корни уравнения. Убедитесь, что значения функции на концах отрезков имеют разные знаки."""

a1 = -1.8
b1 = -1.4
print(f(a1)*f(b1) < 0)

a2 = 0
b2 = 1
print(f(a2)*f(b2) < 0)

"""С помощью реализованной ранее функции `bisection` вычислите с точностью до 9 знаков после запятой корни уравнения на найденных на предыдущем шаге отрезках"""

x1, _, _ = bisection(f, a1, b1) 
x2, _, _ = bisection(f, a2, b2)

[x1, x2]

"""Сделайте проверку, вычислив значения $f(x)$ для найденных корней. Покажите, что полученные значения близки к нулю."""

print(f(x1))
print(f(x2))

"""#### Изучение работы метода деления отрезка пополам

С помощью библиотеки `matplotlib` анимируйте работу метода деления отрезка пополам для нахождения одного из корней и проанализируйте полученный результат.

Для наглядности используйте небольшое значение точности (например, до третьего знака после запятой)
"""

import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import numpy as np

from matplotlib import rc
rc('animation', html='jshtml')

plt.rcParams['figure.figsize'] = [12, 8]

a = a1
b = b1
_, n, x_list = bisection(f, a, b, 10e-3)

fig, ax = plt.subplots()

ax.axhline(y = 0, color = 'k')

ax.plot([a, a], [0, f(a)], 'r:')
ax.plot([b, b], [0, f(b)], 'r:')

# Ваш код построения графика функции на отрезке [a, b] с шагом 0.01 
xx = np.arange(-1, 1, 0.01)
yy = funk(xx)
ax.plot(xx, yy, 'b')
ax.axhline(y = 0, color = 'k')
plt.show()
# Отобразите его синим цветом ('b')

def animate(i):
  """
  Функция animate рисует точку на графике, вычисленную в текущей итерации
  """
  x_i = x_list[i] # Ваше значение на i-й итерации
  f_i = f(x_i)
  ax.plot([x_i, x_i], [0, f_i], 'r:')
  ax.plot(x_i, f_i, 'ro')

animation.FuncAnimation(fig, animate, frames=n)

"""##  Метод секущих

Функция должна возвращать 3 значения:
* искомое число $x$
* количество итераций, за которые оно было найдено
* список значений $x$ на каждой итерации
"""

def secant(f, x1, x2, eps=10e-9, max_iter=100):
  x = 0
  n = 0
  x_list = [x1, x2]
  f1 = f(x1)
  f2 = f(x2)

  while abs(x2-x1) > eps and n < max_iter:
    n+= 1
    x = (x1 * f2 - x2* f1) / (f2 - f1)
    x_list.append(x)
    x1, x2 = x2, x
    f1, f2 = f2, f(x)

  return x, n, x_list

"""#### Использование метода секущей

С помощью реализованной ранее функции `secant` вычислите с точностью до 9 знаков после запятой корни уравнения на отрезках, использованных на методе деления отрезка пополам
"""

x1, _, _ = secant(f, a1, b1) 
x2, _, _ = secant(f, a2, b2)

[x1, x2]

"""Сделайте проверку, вычислив значения $f(x)$ для найденных корней. Покажите, что полученные значения близки к нулю."""

f(x1)
f(x2)

"""#### Изучение работы метода секущей

Выполните код из ячейки ниже. При корректной реализации функции `secant` отобразится анимация работы метода секущей.

Проанализируйте работу метода секущей пошагово.
"""

import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import numpy as np

from matplotlib import rc
rc('animation', html='jshtml')
plt.rcParams['figure.figsize'] = [12, 8]

a = a1
b = b1
_, n, x_list = secant(f, a, b, 10e-3)

fig, ax = plt.subplots()

ax.axhline(y = 0, color = 'k')
ax.plot([a, a], [0, f(a)], 'r:')
ax.plot([b, b], [0, f(b)], 'r:')

xx = np.arange(a, b, 10e-4)
yy = np.vectorize(f)(xx)
ax.plot(xx, yy, 'b')

def animate(i):
  """
  Функция animate для каждой итерации рисует хорду и найденное приближение
  """
  i += 2 # прибавляем 2, чтобы пропустить два заданных приближения
  x1, x2 = x_list[i - 2 : i]
  ax.plot([x1, x2, x_list[i]], [f(x1), f(x2), 0], 'r') # рисуем хорду
  ax.plot([x_list[i], x_list[i]], [0, f(x_list[i])], 'r:')
  ax.plot(x_list[i], f(x_list[i]), 'ro')

animation.FuncAnimation(fig, animate, frames=n)

"""## Метод Ньютона (метод касательных)

Реализуйте функцию `newton(f, df, x0, eps, max_iter)`, находяющую решение нелинейного уравнения $𝑓(𝑥)=0$ c начальными приближениями $x_1$ и $x_2$ с точностью $\epsilon$ с помощью метода секущей.

Параметры функции: 
* `f` - функция от одного числового аргумента;
* `df` - функция, вычисляющая производную функции $f(x)$ в точке;
* `x0` - первоначальное приближение;
* `eps` - точность решения.

Функция должна возвращать 3 значения:
* искомое число $x$;
* количество итераций, за которые оно было найдено;
* список значений $x$ на каждой итерации.
"""

def newton(f, df, x0, eps=10e-9, max_iter=100):
  x = x0 + f(x0) / df(x0)
  n = 1
  x_list = [x0, x]
  # Ваша реализация метода Ньютона
  while abs(x - x0) > eps and n < max_iter:
    n += 1
    x0 = x
    x = x0 + f(x0) / df(x0)
    x_list.append(x)

  return x, n, x_list

"""#### Использование метода Ньютона

С помощью SymPy найдите производную функции $f(x)$ для своего варианта.
"""

from sympy import *

x = symbols('x')

# Ваша реализация нахождения производной функции в символьном виде
# Результат положите в переменную df_expr
x = symbols('x')
f_expr = exp(2*x) * sin(x) - cos(x)
df_expr = diff(f_expr, x)
print(df_expr)

df = lambdify([x], df_expr)

"""С помощью реализованной ранее функции `newton` вычислите корни уравнения с точностью до 9 знаков после запятой. 

В качестве начальных приближений используйте результат работы метода деления отрезка пополам с точностью до 2 знаков после запятой.
"""

x0_1, _, _ = bisection(f, a1, b1)# Нахождение начального приближения для отрезка [a1, b1]
x0_2, _, _ = bisection(f, a2, b2)# Нахождение начального приближения для отрезка [a2, b2]

x0_1, x0_2

x1, _, _ = newton(f, df, x0_1) 
x2, _, _ = newton(f, df, x0_2) 

[x1, x2]

"""Сделайте проверку, вычислив значения $𝑓(𝑥)$ для найденных корней. Покажите, что полученные значения близки к нулю."""

f(x1), f(x2)

"""#### Изучение работы метода Ньютона

Выполните код из ячейки ниже. При корректной реализации функции `newton` отобразится анимация работы метода Ньютона.

Проанализируйте работу метода Ньютона пошагово. При необходимости измените начальное приближение `x0`.
"""

import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import numpy as np

from matplotlib import rc
rc('animation', html='jshtml')
plt.rcParams['figure.figsize'] = [12, 8]

fig, ax = plt.subplots()

x0 = b # при необходимости измените начальное приближение

x, n, x_list = newton(f, df, x0, 10e-3)

xx = np.arange(min(x_list), max(x_list), 10e-4)
yy = np.vectorize(f)(xx)
ax.plot(xx, yy, 'b')

ax.axhline(y = 0, color = 'k')
ax.plot([x0, x0], [0, f(x0)], 'r:')

def animate(i):
  prev, cur = x_list[i], x_list[i + 1]
  ax.plot([prev, cur], [f(prev), 0], 'r') # рисуем касательную
  ax.plot([cur, cur], [0, f(cur)], 'r:')
  ax.plot(cur, f(cur), 'ro')

animation.FuncAnimation(fig, animate, frames=n)
